const fs = require('fs-extra');
const path = require('node:path');
const yaml = require('js-yaml');
const { getPatternLibrariesDir } = require('./paths.js');

/**
 * Load pattern domains from _manifest.yaml
 * @returns {Array<{name: string, value: string, description: string, patternsCount: number, checked: boolean}>}
 */
function loadPatternDomains() {
  const manifestPath = path.join(getPatternLibrariesDir(), '_manifest.yaml');

  const content = fs.readFileSync(manifestPath, 'utf8');
  const docs = yaml.loadAll(content);
  const manifest = Object.assign({}, ...docs.filter(Boolean));

  // Default selected domains
  const defaultSelected = new Set(['prd', 'agile-process']);

  const domains = [];
  for (const [key, lib] of Object.entries(manifest.libraries || {})) {
    if (key === 'core' || lib.required) continue;

    domains.push({
      name: `${key} - ${lib.description} [${lib.patterns_count} patterns]`,
      value: key,
      description: lib.description,
      patternsCount: lib.patterns_count || 0,
      checked: defaultSelected.has(key),
    });
  }

  return domains;
}

/**
 * Merge pattern libraries into a single YAML string
 * @param {string[]} selectedDomains - Array of domain names to include (core is always included)
 * @returns {string} - Merged YAML content
 */
function mergePatternLibraries(selectedDomains) {
  const patternLibrariesDir = getPatternLibrariesDir();

  const allDomains = ['core', ...selectedDomains];
  const mergedPatterns = {
    library_metadata: {
      version: '1.0.0',
      generated_at: new Date().toISOString(),
      included_domains: allDomains,
      description: 'Merged pattern library generated by installer',
    },
  };

  let totalPatterns = 0;

  for (const domain of allDomains) {
    const filePath = path.join(patternLibrariesDir, `${domain}.yaml`);
    if (!fs.existsSync(filePath)) {
      continue;
    }

    const content = fs.readFileSync(filePath, 'utf8');
    const docs = yaml.loadAll(content);
    const libraryData = Object.assign({}, ...docs.filter(Boolean));

    // Track pattern count from metadata
    if (libraryData.library_metadata?.patterns_count) {
      totalPatterns += libraryData.library_metadata.patterns_count;
    }

    // Merge each category (skip metadata)
    for (const [category, patterns] of Object.entries(libraryData)) {
      if (category === 'library_metadata') continue;

      if (!mergedPatterns[category]) {
        mergedPatterns[category] = {};
      }

      // Merge patterns from this category
      if (typeof patterns === 'object' && patterns !== null) {
        Object.assign(mergedPatterns[category], patterns);
      }
    }
  }

  mergedPatterns.library_metadata.patterns_count = totalPatterns;

  return yaml.dump(mergedPatterns, { lineWidth: 120, noRefs: true });
}

module.exports = {
  loadPatternDomains,
  mergePatternLibraries,
};
